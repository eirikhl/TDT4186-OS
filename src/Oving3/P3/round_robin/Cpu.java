package Oving3.P3.round_robin;

import sun.awt.image.ImageWatched;

import java.util.LinkedList;

/**
 * This class implements functionality associated with
 * the CPU unit of the simulated system.
 */
public class Cpu {
    LinkedList<Process> queue;
    long maxTime;
    Oving3.P3.round_robin.Statistics stats;

    Process curProcess;

    long timePassed;

    /**
     * Creates a new CPU with the given parameters.
     * @param cpuQueue		The CPU queue to be used.
     * @param maxCpuTime	The Round Robin time quant to be used.
     * @param statistics	A reference to the statistics collector.
     */
    public Cpu(LinkedList<Process> cpuQueue, long maxCpuTime, Oving3.P3.round_robin.Statistics statistics) {
        // Complete?
        this.queue = cpuQueue;
        this.maxTime = maxCpuTime;
        this.stats = statistics;

        this.curProcess = null;
    }

    /**
     * Adds a process to the CPU queue, and activates (switches in) the first process
     * in the CPU queue if the CPU is idle.
     * @param p		The process to be added to the CPU queue.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event insertProcess(Process p, long clock) {
        // Complete?
        queue.add(p);
        return switchProcess(clock);
    }

    /**
     * Activates (switches in) the first process in the CPU queue, if the queue is non-empty.
     * The process that was using the CPU, if any, is switched out and added to the back of
     * the CPU queue, in accordance with the Round Robin algorithm.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event switchProcess(long clock) {
        // InComplete
        Process temp = getActiveProcess();
        Event event;

        if ( timePassed >= maxTime ) event = new Event(3, clock );
        else if(null == this.getActiveProcess()) event = new Event(1, clock); //not correct
        else if( queue.isEmpty() ) event = null; // not correct
        else if( temp.getCpuTimeNeeded() <= timePassed ) event = new Event(2,clock);
        else event = null;

        return event;
    }

    /**
     * Called when the active process left the CPU (for example to perform I/O),
     * and a new process needs to be switched in.
     * @return	The event generated by the process switch, or null if no new
     *			process was switched in.
     */
    public Event activeProcessLeft(long clock) {
        // Incomplete
        /*
         Need to return event(2) if process left because it ended
                        event(3) if process left because time quant expired
                        event(4) if process left to perform I/O ??
          */
        if(!queue.isEmpty()){
            curProcess = queue.pollFirst(); // Get first element of ready queue
            curProcess.updateTimeSpentWaiting(clock); // Update the time spent in ready queue
            curProcess.updateEventTime(clock); // Update the time at which something happened to the Process
            return new Event(3, clock);
        }
        return null;
    }

    /**
     * Returns the process currently using the CPU.
     * @return	The process currently using the CPU.
     */
    public Process getActiveProcess() {
        // Complete? - Don't see why not
        return curProcess;
    }

    /**
     * This method is called when a discrete amount of time has passed.
     * @param timePassed	The amount of time that has passed since the last call to this method.
     */
    public void timePassed(long timePassed) {
        // Incomplete
        // ??dafaq dis do??
        // basically update the timePassed field? o.O
        this.timePassed = timePassed;
    }
}
