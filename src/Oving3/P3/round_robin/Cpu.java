package Oving3.P3.round_robin;

import java.util.LinkedList;

/**
 * This class implements functionality associated with
 * the CPU unit of the simulated system.
 */
public class Cpu {
    LinkedList<Process> queue;
    long maxTime;
    Oving3.P3.round_robin.Statistics stats;

    Process curProcess;

    long timePassed;
    private long cpuTimeLeft;


    /**
     * Creates a new CPU with the given parameters.
     *
     * @param cpuQueue   The CPU queue to be used.
     * @param maxCpuTime The Round Robin time quant to be used.
     * @param statistics A reference to the statistics collector.
     */
    public Cpu(LinkedList<Process> cpuQueue, long maxCpuTime, Oving3.P3.round_robin.Statistics statistics) {
        // Complete?
        this.queue = cpuQueue;
        this.maxTime = maxCpuTime;
        this.stats = statistics;

        this.curProcess = null;
    }

    /**
     * Adds a process to the CPU queue, and activates (switches in) the first process
     * in the CPU queue if the CPU is idle.
     *
     * @param p     The process to be added to the CPU queue.
     * @param clock The global time.
     * @return The event causing the process that was activated to leave the CPU,
     * or null	if no process was activated.
     */
    public Event insertProcess(Process p, long clock) {
        // Complete?
        if(null == p) return null;
        queue.add(p);
        p.updateNofTimesInReadyQueue();

        return switchProcess(clock);
    }

    /**
     * Activates (switches in) the first process in the CPU queue, if the queue is non-empty.
     * The process that was using the CPU, if any, is switched out and added to the back of
     * the CPU queue, in accordance with the Round Robin algorithm.
     *
     * @param clock The global time.
     * @return The event causing the process that was activated to leave the CPU,
     * or null	if no process was activated.
     */
    public Event switchProcess(long clock) {
        // InComplete
        Process curr = getActiveProcess();
        if (curr != null) {
            if (this.cpuTimeLeft > 0) return null; // if time quant is not finished
            //adds current process to back of queue and get next process out of queue
            queue.add(curr);
        } else if (queue.isEmpty()) return null;

        cpuTimeLeft = maxTime;

        // if no process in cpu and queue is not empty: next = first in queue
        curProcess = queue.pollFirst();

        // if the time to next io is less than time quant, return io request

        // if time needed is less than time spent, return endProcess event
        if (curProcess.getCpuTimeNeeded() < maxTime && curProcess.getCpuTimeNeeded() < curProcess.getTimeToNextIoOperation()) {
            stats.nofCompletedProcesses++;
            return new Event(Event.END_PROCESS, clock + curProcess.getCpuTimeNeeded());
        }

        if (curProcess.getTimeToNextIoOperation() <= maxTime)
            return new Event(Event.IO_REQUEST, clock + curProcess.getTimeToNextIoOperation());

        stats.nofProcessSwitches++;
        return new Event(Event.SWITCH_PROCESS, clock + maxTime);
    }

    /**
     * Called when the active process left the CPU (for example to perform I/O),
     * and a new process needs to be switched in.
     *
     * @return The event generated by the process switch, or null if no new
     * process was switched in.
     */
    public Event activeProcessLeft(long clock) {
        // Incomplete

        curProcess = null;
        return switchProcess(clock);

    }

    /**
     * Returns the process currently using the CPU.
     *
     * @return The process currently using the CPU.
     */
    public Process getActiveProcess() {
        // Complete? - Don't see why not
        return curProcess;
    }

    /**
     * This method is called when a discrete amount of time has passed.
     *
     * @param timePassed The amount of time that has passed since the last call to this method.
     */
    public void timePassed(long timePassed) {
        // Incomplete
        this.timePassed = timePassed;
        this.cpuTimeLeft -= timePassed;

        for (Process p : queue) {
            p.updateTimeSpentWaiting(timePassed);
        }

        if (null != curProcess) {
            curProcess.updateTimeSpentInCpu(timePassed);
            curProcess.updateTimeToNextIoOperation(timePassed);
            stats.totalBusyCpuTime += timePassed;
        }

        if(stats.cpuQueueLargestLength < queue.size()) stats.cpuQueueLargestLength = queue.size();
        stats.cpuQueueLengthTime += queue.size()*timePassed;
    }
}
